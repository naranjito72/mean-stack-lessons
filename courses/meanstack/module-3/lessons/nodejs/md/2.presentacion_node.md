class: center, middle, inverse

<img src="https://imgur.com/9b2Dc5n.png" width=50% height=50% alt="logo">


---

name: contenido
class: center, middle, inverse
## [Node.js](#Qué es Node.js?)
---
name: default
layout: true
task: &nbsp;

.task[{{task}}]

---
name:contenido

###Contenido

- [Introducción](#introduccion)
- [Instalación](#instalacion)
- [npm](#npm)
- [módulos](#modulos)
- [callbacks](#callbacks)
- [promesas](#promesas)
- [async-await](#asyncawait)
- [EventEmitter](#eventemitter)
- [Buffers](#buffers)
- [Streams](#streams)
- [FileSystem](#fs)
- [http](#http)
- [socket.io](#socket)

---
name:introduccion
task: [<< índice de contenidos >>](#contenido)

### Qué es Node.js?

Node.js (o abreviadamente _Node_) es un entorno de ejecución para JavaScript construido con el motor de JavaScript V8 de Chrome desarrollado por Ryan Dahl, cuando estaba en Joyent. Dahl creó Node debido a las [limitaciones síncronas de los _frameworks_ web actuales](https://www.infoq.com/interviews/node-ryan-dahl). Node nos permite correr JavaScript en cualquier sitio, incluidos servidores web y robots

En el pasado, el único entorno de ejecución para JavaScript era el navegador. Chrome, Safari y Internet Explorer tenían su propio entorno, pero no podíamos correr JavaScript fuera de ellos.

Dahl cambió esto extrayendo `el entorno de ejecución V8` de Chrome, y creando una implementación para servidores.

### Qué no es

- ***No*** es un _framework_ (Hay _frameworks_ construidos sobre Node.js)
  
- ***No*** es un lenguaje de programación (el lenguaje es JavaScript)
---
task: [<< índice de contenidos >>](#contenido)
### Por qué Node.js?

- Porque utiliza JavaScript. Lenguaje universal de programación. Su curva de aprendizaje es menor para los que están familiarizados con el JavaScript de lado de cliente:

<img class="centered" src="https://imgur.com/BIdlJ0B.png">

- Utiliza un modelo orientado a eventos, sin bloqueos de E/S que hace que sea ligero y eficiente, ideal para aplicaciones que requieren datos en tiempo real y que se ejecutan mediante dispositivos distribuidos
  
- Proporciona una amplia biblioteca de varios módulos de JavaScript (> 1.000.000) que simplifica el desarrollo de aplicaciones web usando Node.js


???
Because Node uses JavaScript's *event driven* and *asynchronous* model, it excels with certain web applications such as chat applications, and apps that need real time, live updating features.

Another (subjective and debateable) benefit is the language of JavaScript being universal. Theoretically, the learning curve may be lower for those who are already familiar with front-end JavaScript.

Related to that, is the concept of sharing code on your front end and back end because they're written in the same language, although many agree that back end code is very different, even if it is the same language.

In addition, Node has a strong and growing ecosystem. This includes packages created by the community, and continuing open source development on the runtime itself.


Because Node uses [Google's V8](https://developers.google.com/v8/) behind the scenes, Node also benefits from competition between browsers. As Google improves V8 to compete with [Mozilla's SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey), [Microsoft's Chakra](https://github.com/Microsoft/ChakraCore) and others, Node reaps the benefits of those improvements as well.

---
task: [<< índice de contenidos >>](#contenido)

### Casos de uso

<a href="https://www.netguru.com/blog/top-companies-used-nodejs-production"><img class=centered src=https://imgur.com/TFDerOf.png></a>

<a  href="https://www.youtube.com/watch?v=gtjzjiTI96c&list=PLfXiENmg6yyUpIVY9XVOkbdmBPx6PUm9_" target="_blank"><img class=centered alt="Netflix" src="https://imgur.com/f1i4QE0.png">
</a>

---
name:instalacion
task: [<< índice de contenidos >>](#contenido)

### Instalando Node.js en Windows

- Conectarse a la página oficial: https://nodejs.org/es/

  - __LTS versión__ de Node.js con Long Term Support (LTS). Esta versión puede no tener disponibles las últimas tecnologías que todavía no se consideran estables.

  - __Current__: esta es la versión más reciente de Node.js e incluye todas las funcionalidades, incluso aquellas más novedosas y que no se consideran estables. Las versiones pares pasan a versiones lts (el actual Node 12 2019 pasará en Octubre a ser LTS, con soporte hasta 2022)

- Descargar el __archivo .msi__ y seguir las instrucciones para instalar Node.js. De forma predeterminada, el instalador establece el directorio
  
   `C:\Archivos de programa\nodejs\bin` en las variable de entorno `PATH` de windows. 

- Para comprobar si Node se ha instalado, desde un terminal tecleamos:
      
.inverse[<pre class=codigo>node --version</pre>
]
---
task: [<< índice de contenidos >>](#contenido)
### Node 12
Pasará a LTS en Octubre 2019, incorpora las siguientes mejoras:

1. __Soporte a módulos ECMAScript__. Se podrán utilizar comandos `import` / `export` sin necesidad de utilizar paquetes específicos. Soporte para 3 tipos de `import`:

```javascript
// default exports
import module from 'module'
// named exports
import { namedExport } from 'module'
// namespace exports
import * as module from 'module'
```
Si se importa de un package `CommonJS`, sólo se puede utilizar el `import` de la sintaxis de `default export`: `import module from 'cjs-library'`.

También se puede utilizar `import()`dinámico para cargar ficheros en tiempo de ejecución. `import()`devuelve una _promesa_ que puede ser utilizada en módulos ES y CommonJS, indistintamente.

---

#### 2. V8 Engine

- Node 12  utilizará la versión 7.4 del motor V8 de google que aporta:

  - Parseo más rápido de JavaScript
  - Llamadas más rápidas a funciones con disparidad de argumentos
  - `await` más rápido

---

#### 3. Uso de campos privados en clases

se utilizará el simbolo `#` symbol.

    class Greet {
      #name = 'World';
      get name() {
        return this.#name;
      }
      set name(name) {
        this.#name = name;
      }
      sayHello() {
        console.log(`Hello, ${this.#name}`);
      }
    }

Si se intenta acceder a #name desde fuera de la clase se obtendrá un _syntax error_.

    const greet = new Greet()
    greet.#name = 'NewName';
    // -> SyntaxError
    console.log(greet.#name)
    // -> SyntaxError
---
#### 4. Rendimiento mejorado de arranque

Node 12 presenta una caché de código binario  para sus propias librerías que mejora el tiempo de arrancada en un 30%.

#### 5. TLS y Seguridad

Soporte a TLS 1.3, que mejora la seguridad y reduce la latencia. Node reduce también el tiempo de "saludo" requerido por el protocolo HTTPS (HTTPS handshake). 

#### 6. Tamaño del Heap de memoria mejorado

Node determina el tamaño de memoria que se asigna a memoria dinámica sin reservarla previamente

#### 7. Funcionalidad de volcado Heap (Heap dump)

Node 12 provides the ability to generate a heap dump making it easier to investigate memory issues.

#### 8. Informes de Diagnóstico 

Node offers improved ability to diagnose issues (performance, CPU usage, memory, crashes, etc) within applications by providing an experimental diagnostic report feature.
---
#### 9. Mejora del uso de módulos nativos de N-API

N-API was released to provide a more stable and native Node module system that would prevent libraries from breaking on every release by providing an ABI-stable abstraction over native JavaScript APIs. Node 12 offers improved support for N-API in combination with worker threads.

#### 10. Otras mejoras

- Worker Threads no longer require a flag
- http has updated its default parser to be llhttp
- assert validates required arguments and adjusts loose assertions
- buffer improvements to make it more stable and secure
- async_hooks removes deprecated functionality
- Make global.process, global.Buffer getters to improve process
- A new welcome message for repl


---
task: [<< índice de contenidos >>](#contenido)

### Usos de Node

Utilizaremos Node para escribir aplicaciones de JavaScript puras y, para crear un servidor web con Express.

### Primer programa en Node
<hr>
Crear un archivo en el directorio de trabajo llamado `test.js`.

En este fichero añadiremos el siguiente código:
```javascript
    console.log("Hello Node");
```

En el **terminal**:

.inverse[<pre class=codigo>node test</pre>
 Hello Node]

Se puede escribir cualquier código JavaScript teniendo en cuenta que __no hay DOM__

---
task: [<< índice de contenidos >>](#contenido)

### Segundo programa: Instalando un servidor web


1. Creamos un directorio para la aplicacion y entramos:

.inverse[<pre class=codigo-dir><span class=codigo> md prueba-node<span><pre class=codigo-dir><span class=codigo> cd prueba-node<span></pre></pre>
]


2. Creamos un archivo __index.js__ dentro de la carpeta anterior, con el siguiente contenido:
   

    const http = require("http");
    const handler = (request, response) => {
      console.log('Recibimos peticion');
      response.end("<p>Hola Mundo web</p>");
      }
    const server = http.createServer(handler);
    server.listen(8080);
    console.log('Server running at http://127.0.0.1:8080/');
3. Ejecutamos Node desde el terminal:
.inverse[<pre class=codigo>node index</pre>
]
???
Crearemos una aplicación web con "Hello, World!" con los siguientes Componentes:
Import de los módulos requeridos − Mediante la directiva require que carga módulos Node.js.
Create server − Genera un servidor que escucha peticiones http
Escucha peticiones y devuelve respuestas − El servidor recibe una petición http de un cliente, navegador o consola y devuelve una respuesta

---
name:npm
task: [<< índice de contenidos >>](#contenido)

### npm & módulos


### Intro

**npm** es el gestor de paquetes de Node. Significa que todos los programadores pueden compartir código fácilmente usando un terminal de línea de comando

npm tiene el ecosistema de paquetes externos más potente de todas las comunidades de programación con más de un 1.000.000 de módulos para descargar!

**Módulos** son fragmentos de código reutilizable empaquetados con todo el código del que dependen (dependencias)

---
task: [<< índice de contenidos >>](#contenido)

#### Utilizando packages npm: Instalación de un módulo

.inverse[<pre class=codigo>npm install --save chalk</pre>
]

`npm install` se dirige a los servidores de npm y selecciona un package llamado "chalk". `--save` añade la dependencia al archivo `package.json`.

Además, se ha creado un directorio `node_modules`, donde se almacena el módulo `chalk`.

Para utilizar el módulo dentro de un fichero `index.js`:

```javascript
const chalk = require('chalk');
console.log(chalk.blue('Hello, npm!'));
```
Ejecutamos desde el terminal:
.inverse[<pre><span class=codigo>node index<span><span style="color:lightblue;display:block;">Hello npm</span></pre>
]
Toda la funcionalidad se encuentra en la página de [documentación](https://www.npmjs.com/package/chalk) del package. 

!!!IMPORTANTE:: **NUNCA COMMIT DE `node_modules` a GIT**. 

Para recrear el directorio `node_modules` utilizamos el comando __`npm install`__.
---
task: [<< índice de contenidos >>](#contenido)
#### Utilizando packages npm: Otros comandos

Por defecto NPM instala las dependencias en modo local. Es decir, crea un directorio node_modules dentro del directorio donde estamos ejecutando el comando. 
Se puede usar `npm ls` para listar los módulos instalados en local.

En la instalación global los paquetes se almacenan en el directorio system. Estas dependencias se pueden utilizar con un CLI (Command Line Interface) pero no se pueden importar en la aplicación directamente con require()

.inverse[<pre class=codigo>npm install nodemon -g</pre>
]

Para desinstalar un package:.inverse[<pre class=codigo>npm uninstall chalk</pre>
]
Para actualizar un package:.inverse[<pre class=codigo>npm update chalk</pre>
]
Para buscar un package:.inverse[<pre class=codigo>npm search chalk</pre>
]


---
task: [<< índice de contenidos >>](#contenido)
### Ejercicio 1
<hr>
Instalar un package de la siguiente [lista](https://github.com/sindresorhus/awesome-nodejs#weird), en especial de la sección "raritos" (_weird_).

Usar el package seleccionado en el archivo `index.js`. 
<br>
<br>
<br>

### Ejercicio 2
<hr>
Importar la librería “os”

Obtener datos sobre cpu, sistema y servidor

Imprimirlos en el navegador

---
task: [<< índice de contenidos >>](#contenido)
### Mi primer package npm: Registro


1. Regístrate en [npm](https://www.npmjs.com/signup) para tener una cuenta
2. Desde el [terminal](https://www.davidbaumgold.com/tutorials/command-line/) tecleamos:

.inverse[<pre class=codigo>npm adduser</pre>
]

  También podemos utilizar:
.inverse[<pre class=codigo>npm login</pre>
]

El terminal nos solicita ahora `username`, `password` y `email`. 

En este momento obtenemos un mensaje similar a éste:

.inverse[<pre>Logged in as rglepe on https://registry.npmjs.org/</pre>
          ]

Importante!!! Hay que verificar el mail desde la cuenta de correo.
---
task: [<< índice de contenidos >>](#contenido)

### Mi primer package npm: Preparación

Desde un directorio de trabajo, llamaremos a nuestro package __minimalista__ e introduciremos una serie de instrucciones:

.inverse[<pre class=codigo-dir><span class=codigo> md minimalista<span></pre>
]

Entramos al directorio creado:
.inverse[<pre class=codigo-dir><span class=codigo> cd minimalista<span></pre>
]

Para trabajar con npm es necesario definir un archivo de tipo _manifest_, que es un fichero donde se listan todas las dependencias de terceros que tiene nuestro programa. Este archivo es [package.json](https://docs.npmjs.com/files/package.json) :

.inverse[<pre class=codigo> fsutil file createNew package.json 0</pre>
]

Crearemos un package npm con la información imprescindible en el fichero package.json: __nombre__ y __versión__
.inverse[<pre style="color: red;">{
  "name": "@rglepe/minimalista",<br>  "version": "1.0.0"<br>}</pre>]
---
task: [<< índice de contenidos >>](#contenido)

### Mi primer package npm: Publicación

Para publicar el package npm, corremos la instrucción:
.inverse[<pre class=codigo>npm publish --access=public</pre>
]
_Por defecto los packages se publican con visibilidad private. Para evitar esto usaremos el modificador `--access=public`_

Una vez ejecutado, aparecerá un signo "+", el nombre del package y la versión.
.inverse[<pre>+ @rglepe/minimalista@1.0.0</pre>
]
!!!Ahora ya pertenecemos al __club npm__!!!


Recibiremos también un mail:
<img src="https://imgur.com/kJwAabw.png" width=75% height=75%>

Ya tenemos la versión 1 del package: https://www.npmjs.com/package/@rglepe/minimalista/v/1.0.0
---
task: [<< índice de contenidos >>](#contenido)
### Package npm completo

Usaremos un repositorio [GitHub](https://github.com/new) al que añadiremos un fichero _readme_ con las instrucciones necesarias para utilizar el package y...el código del package.

__fichero README!__
<hr>
Vamos añadir una serie de etiquetas desde [shields.io](https://shields.io/) de forma que parezca que somos muy profesionales:

Vamos añadir la versión actual del package (npm scoped):

![npm (scoped)](https://img.shields.io/npm/v/@rglepe/minimalista.svg)

Y el tamaño del package (npm bundled size minified). 

*_Si todavía no hemos introducido el código, nos dará un error de inaccesible_:

![npm bundled size(minified)](https://img.shields.io/bundlephobia/min/@rglepe/minimalista.svg)
---
task: [<< índice de contenidos >>](#contenido)
### Package npm completo

__Licencia__
<hr>

Una licencia permite conocer las condiciones de uso de nuestro package existen [muchas diferentes](https://choosealicense.com/).
Dentro del apartado __insights__ de cada repositorio GitHub podemos seleccionar distintos estados — incluyendo los recomendados por la comunidad: 

<img src="https://imgur.com/Xt1FtFb.png" class=centered>

Aquí seleccionamos "Choosing a License", y después:

<img src="https://imgur.com/3OomQY6.png" class=centered>
---
task: [<< índice de contenidos >>](#contenido)
          
### Package npm completo

__Código__
<hr>
Una función para eliminar espacios de un string:

    module.exports = function minimalista(string) {
      if (typeof string !== "string") throw new TypeError
      ("Minimalista requiere un string!");
      return string.replace(/\s/g, "");
    };

Añadimos el código dentro de un archivo __index.js__. Este será el _entry point_ a nuestro package.

Completamos nuestro __package.json__ básico y añadimos instrucciones al fichero __readme.md__, para explicar el uso de nuestro código.
---
task: [<< índice de contenidos >>](#contenido)
### Package npm completo

__package.json__
<hr>
Añadimos: 

    {
      "name": "@rglepe/minimalista",
      "version": "1.0.0",
      "description": "Removes all spaces from a string",
      "license": "MIT",
      "repository": "bcncodes-training/minimalista",
      "main": "index.js",
      "keywords": [
        "minimalista",
        "npm",
        "package",
        "bcncodes-training"
      ]
    }
---
task: [<< índice de contenidos >>](#contenido)
### Package npm completo

__readme.md__
<hr>
Añadimos instrucciones de cómo utilizar el package. Si necesitas alguna plantilla, échale un vistazo a la comunidad y usa alguno de sus formatos para empezar.

<img class="centered" src="https://imgur.com/XSV5iku.png">
---
task: [<< índice de contenidos >>](#contenido)
### Package npm completo

1. Actualizamos la versión npm mediante la instrucción:
.inverse[<pre class=codigo>npm version major</pre>
]

Que genera:          .inverse[<pre>v2.0.0</pre>
]

2. Publicamos:
.inverse[<pre class=codigo>npm publish --access=public</pre>
]

Obtenemos:
.inverse[<pre>+ @rglepe/minimalista@2.0.0</pre>
]
---
task: [<< índice de contenidos >>](#contenido)

## Utilidades

- [Package Phobia](https://packagephobia.now.sh/result?p=%40rglepe%2Fminimalista) ofrece un resumen del package npm.

- También podemos revisar los ficheros en [Unpkg](https://unpkg.com/@rglepe/minimalista@2.0.2/)

---
task: [<< índice de contenidos >>](#contenido)
###Ejercicio a entregar: Introducción a Node
<hr>

Clona la rama del repositorio `github.com/bcncodes-training/intro-node.git` que lleva tu nombre. Una vez completado el ejercicio actualiza tu rama.

---
task: [<< índice de contenidos >>](#contenido)

### Recursos extras

- [Getting the best out of NPM](https://jsblog.insiderattack.net/getting-the-best-out-of-npm-b73d4a8fbf29#.hehmw1xun) - More advanced NPM concepts


---

name: modulos
class: center, middle, inverse
## [Módulos en Node.js](#Qué es Node.js?)
---
name:modulosintro
task: [<< índice de contenidos >>](#contenido)

### Módulos Node: Intro

Los módulos en Node.js son funcionalidades simples o complejas organizadas en uno o varios ficheros JavaScript, completamente independientes entre si,  y que pueden ser mezclados, añadidos y eliminados, sin alterar el sistema en su conjunto. 

![](https://imgur.com/dSzASCp.png)

---
task: [<< índice de contenidos >>](#contenido)

### Módulos Node: Ventajas

Sobre todo cuando el sistema crece, y queremos independizar bloques de código

__Mantenimiento__, un modulo bien diseñado, disminuye al máximo las dependencias, por tanto su crecimiento o rediseño no afecta a los demás

__Espacios de nombre__, cada módulo, es capaz de crear sus variables en un espacio privado (tiene contexto propio), sin contaminar al resto de módulos

__Reutilización__, un módulo es susceptible de ser usado por diversas aplicaciones en distintos contextos, ya que expone una interficie

---
task: [<< índice de contenidos >>](#contenido)

### Origen de los módulos de Node.js: Revealing Module Pattern

- El principio central de este patrón de diseño es que todas las funcionalidades y variables deberían estar encapsuladas a menos que se expongan de forma deliverada
- Para implementar el patrón en JavaScript se utilizan los [_closures_](https://developer.mozilla.org/es/docs/Web/JavaScript/Closures) y las [IIFEs](https://developer.mozilla.org/es/docs/Glossary/IIFE)
```javascript
      var modulo = (function() {
        var privMetodo = function() {...};
        var privVariable = [];
        var export = {
        publicMetodo: function() {...},
        publicVar: function() {...}
        }
    
        return export;
        })();
```
---
task: [<< índice de contenidos >>](#contenido)

### Módulos Node: CommonJS

- Es un grupo de trabajo que surge con el objetivo de estandarizar el ecosistema JavaScript y una de sus propuestas fueron los módulos CommonJS
  
- La librería CommonJS es, por tanto, la implementación del patrón revealing module en javascript

- CommonJS ofrece:

  + Una sintaxis compacta
  + Diseño para carga síncrona
  + Principal uso en servidores

---
task: [<< índice de contenidos >>](#contenido)
### Módulos Node: Definición de un módulo CommonJS

La definición de un módulo CommonJS se realiza de la siguiente manera: 
```javascript
    const myModule {

        hello: () => 'hello!';
        goodbye:() => 'goodbye!';
      
    }

    module.exports = myModule;
```
---
task: [<< índice de contenidos >>](#contenido)

### Módulos Node: Utilización de un módulo CommonJS

Para utilizar el módulo desarrollado con CommonJS usamos el método `require()`:

    const myModule = require('myModule');

    myModule.hello(); 
    myModule.goodbye(); 

De este modo, se evita la contaminación de namespaces globales, y las dependencias se vuelven mas explícitas.

---
task: [<< índice de contenidos >>](#contenido)
### Módulos Node: CommonJS en Node

- Node lleva incorporado en el core a CommonJS como sistema de módulos

- En NodeJS cada fichero .js es tratado como un módulo separado

- Los módulos __se cargan en memoria__ una vez y luego __son reutilizados__
---
task: [<< índice de contenidos >>](#contenido)

### Diseño modular: Carga de módulos NodeJS

Node.js puede cargar dependencias utilizando la palabra clave “require” y asignando el módulo cargado a una variable, como se puede ver en el ejemplo:

    const http = require('http'); 
    const dns = require('dns');


También se pueden cargar archivos en rutas relativas:

    const myFile = require('./myFile');


Si se instalan módulos desde npm, se manejan como los nativos, sin necesidad de especificar la ruta absoluta o relativa:

      const express = require('express');

---
task: [<< índice de contenidos >>](#contenido)

### Diseño modular: Exportar desde módulos NodeJS

Los módulos en Node.js no se inyectan automáticamente en el ámbito global, sino que simplemente se asignan a una variable. 

Para exportar funciones o variables de un módulo se utiliza el objeto __`module.exports`__ o __`exports`__. 
- __Exports__ es un objeto especial que se incluye en todos los ficheros JS de Node, por defecto. 
- __module__ es una variable que representa el módulo actual y 
- __exports__ es un objeto que se expondrá como módulo
```javascript
      // book.js
      module.exports.name = 'pepe'; //asigna un valor al módulo
      module.exports.read = function() { 
      console.log('Hola ' + exports.name);
      } 
      //asigna una función a la propiedad read del objeto exports 
      //devuelve el objeto {read: function(){...}}
```
---
task: [<< índice de contenidos >>](#contenido)
### Diseño modular: Exportar desde módulos NodeJS

Con `module.exports` se puede exportar cualquier tipo de objetos, por ejemplo clases:

      // book.js
      module.exports = class book {
      public name;
      constructor(name){this.name = name};
      read = function() { 
      console.log('Hola ' + this.name);
      }}
---
task: [<< índice de contenidos >>](#contenido)
### Diseño modular: Exportar desde módulos NodeJS

Ejemplos de buenos y malos usos de `exports`:

      // calculator-exports-examples.js

      // good
      module.exports = {
        add(a,b) { return a+b }
      }

      // good
      module.exports.subtract = (a,b) => a-b

      // valid
      exports = module.exports

      // good and simply a shorter version of the code above
      exports.multiply = (a,b) => a*b

      // bad, exports is never exported
      exports = {
        divide(a,b) { return a/b }
      }

---
task: [<< índice de contenidos >>](#contenido)
### Diseño modular: ES Modules

Un módulo ES6 es un archivo que contiene código JS. No existe una palabra clave `module`; un módulo se lee casi como cualquier script. Existen dos diferencias.

Se puede usar `import` y `export` en los módulos.

Se puede hacer `export` de cualquier `function`, `class`, `var`, `let`, o `const` declarado al nivel más alto del script.

      //kittydar.js - Encontrar todos los gatos en una imagen.

      export function detectCats(canvas, options) {
        var kittydar = new Kittydar(options);
        return kittydar.detectCats(canvas);
      }

      export class Kittydar {
        //... varios métodos de procesamiento de imágenes ...
      }

      // esta función no será exportada.
      function resizeCanvas(){
        ...   }
Si queremos exportar todo el módulo podemos asignar: __`export default`__.

---
task: [<< índice de contenidos >>](#contenido)
### Diseño modular: ES Modules

En un archivo separado, podemos importar y usar la función detectCats():

    //demo.js - Programa demo Kittydar

    import {detectCats} from "kittydar.js";

    function go(){
      var canvas = document.getElementById("catpix");
      var cats = detectCats(canvas);
      drawRectangles(canvas, cats);
    }
Para importar múltiples nombre de un módulo, se escribiría:

    import {detectCats, Kittydar} from "kittydar.js"

---
task: [<< índice de contenidos >>](#contenido)

### Diseño modular: ES Modules en NodeJS

En NodeJS los módulos ES se encuentran en fase experimental hasta que entre en lts la versión 12. 
Para trabajar con ellos, de momento se requiere crear un fichero con la extensión `.mjs` y activarlo con el flag `--experimental-modules`:

.inverse[<pre class=codigo> node --experimental-modules my-app.mjs</pre>
]

Para exportar un módulo se escribiría:

      //01-kettle.mjs
      export const spout = 'the spout'
      export const handle = 'the handle'
      export const tea = 'hot tea

Para usarlo en otro módulo 01-main.mjs

      import {handle, spout, tea} from './01-kettle.mjs'

      console.log(handle) // ==> the handle
      console.log(spout) // ==> the spout
      console.log(tea) // ==> hot tea

---
task: [<< índice de contenidos >>](#contenido)

### Diferencias CJS Modules vs MJS Modules

- Lós módulos ES6 se cargan de forma asíncrona, mientras que los CJS se cargan de forma síncrona.

- Los modulos ES6 son un estándar multiplataforma, son compatibles con Node.js y navegadores.
  
- Los Imports y Exports en ES6 son estáticos. Permite utilizar sólo la parte útil cuando se usan librerías de terceros.

- En CJS los imports son dinámicos, requieren asignarlos a una variable. Esto ralentiza la carga de los módulos.

---
task: [<< índice de contenidos >>](#contenido)

### Notas sobre el diseño modular

1. Al empezar a diseñar módulos, dos conceptos clave del desarrollo software: __cohesión__ y __desacoplamiento__. Hay que crear módulos que se encuentren muy cohesionados. 
   
  + Los métodos dentro de un módulo deben tener una relación interna

  + Cuanto más __cohesionado__ se encuentran los miembros de un módulo, mayor __reutilización__, __mantenimiento__ y __evolución__ podría llegar a tener, en términos generales.

  +  El concepto de __acoplamiento__, tiene que ver con el __número de dependencias__ que un módulo tiene con otros módulos. 
  
2. Todo módulo, para que esté bien diseñado, debería cumplir con el principio de __única responsabilidad__. 
  
  + Puede ser complicado y depende de muchos parámetros del contexto.
  
  + Cuantas más dependencias tiene un módulo más difícil de testear y más expuesto a cambios en el futuro podría estar.

  + Como, no depender de nada, no es posible, tendremos que crear formas en las que incluir esas dependencias nos generen la menor fricción posible.
---
task: [<< índice de contenidos >>](#contenido)

### Notas sobre el diseño modular

- Tenemos que intentar que dentro de nuestro árbol de dependencias, los módulos que se encuentren en la parte más profundas (en la raíz) sean lo más genéricos posibles y que según nos acerquemos a las hojas, los módulos sean más específicos.
- En capas superiores, el código  se encuentra ya muy ligado a la lógica de nuestro negocio y esto nos obliga a que tenga que ser así. 

- Para conseguir desacoplar el código hay que utilizar la inyección de dependencias: [https://www.npmjs.com/search?q=dependency%20injection](https://www.npmjs.com/search?q=dependency%20injection)

---
task: [<< índice de contenidos >>](#contenido)

### Ejercicio 3
<hr>

- Crear un módulo para importar la librería “`os`” y obtener datos sobre cpu, sistema y servidor

- Crear otro módulo para Imprimir los datos obtenidos en el paso anterior, en el navegador.

TIPs: Utilizar _backticks_ (`tildes francesas`) para incluir variables: `${}`

BONUS: Mismo ejercicio en ES Modules

<br>

---
task: [<< índice de contenidos >>](#contenido)

### Ejercicio 4
<hr>

Guardar los datos anteriores en un fichero.

TIPS: Utilizar el método `appendFile()` del módulo `fs`. Requiere 3 parámetros:
- _Nombre fichero_,
- _Contenido_
- Función `callback`: 
    
    function(error) {if(error){console.log('se ha producido un error');}}

---
task: [<< índice de contenidos >>](#contenido)

### Ejercicio 5

- Crea un módulo que encapsule el procesado de strings para generar procesos:

  + Primera mayúscula
  + Tipo Oración
  + Minúsculas
---
name: callbacks
class: center, middle, inverse
## [Callbacks](#Qué es Node.js?)
---
task: [<< índice de contenidos >>](#contenido)

### callbacks: conceptos

- En JavaScript se usa la notación __CPS__ (abreviatura de _continuation passing style_) para escribir el código de un programa en el que las Continuaciones se escriben y se pasan de forma explícita.

- Cuando se escribe un programa en notación CPS, cada función recibe un parámetro adicional, que representa la Continuación de la función. En lugar de retornar, la función invocará la continuación recibida pasando el valor de retorno. De esta forma, las funciones nunca regresan al código que las llamó, sino que la ejecución del programa transcurre “hacia adelante” sin retornar hasta que el programa finalice.
  
- CPS es un concepto general y no siempre está asociado a programación asíncrona.

---
task: [<< índice de contenidos >>](#contenido)

### callbacks: conceptos

- Las funciones callbacks, por tanto, sustituyen a la instrucción __return__ que requiere la ejecución síncrona.

- En Node todas las APIs soportan el uso de callbacks:


    //CallBacks en programación síncrona
    function add(a, b, callback) { callback(a + b);
    }
    console.log('before'); add(1, 2, function(result) {
       console.log('Result: ' + result);
    });
    console.log('after');
    //Resultado
    before Result: 3 after


    //CallBacks en programación asíncrona
    function addAsync(a, b, callback) { setTimeout(function() { callback(a + b);
    }, 100); }
    console.log('before'); addAsync(1, 2, function(result) { 
      console.log('Result: ' + result);
      }); console.log('after');
    //Resultado before after Result: 3

---
task: [<< índice de contenidos >>](#contenido)

### callbacks: conceptos

Ejemplo: Lectura de un fichero en modo síncrono:

Crear un fichero input.txt con un texto de prueba, en el directorio de un proyecto: ejemploCallBacks
Crear un fichero main.js que importe el módulo fs
Volcar el contenido del fichero a una variable con el método: 

    let data = fs.readFileSync('input.txt');

Imprimir el contenido del fichero por consola.
Imprimir un mensaje por consola ('Fin del programa').

---
task: [<< índice de contenidos >>](#contenido)

### callbacks: conceptos

Ejemplo: Lectura de un fichero en modo asíncrono:

Crear un fichero input.txt con un texto de prueba, en el directorio de un proyecto: ejemploCallBacks
Crear un fichero main.js que importe el módulo fs 
Leer el fichero con el método: 


    let fs.readFile('input.txt', (err, data) => {
      if (err) return console.error(err); console.log(data.toString());
        });
      ;

Imprimir el contenido del fichero por consola.
Imprimir un mensaje por consola ('Fin del programa').

---
task: [<< índice de contenidos >>](#contenido)

### Convenciones de Callbacks en NodeJS 

- Las funciones _callback_ siempre son el último argumento de la función. Ej:


      fs.readFile(filename, [options], callback)

- Los errores siempre se sitúan al principio de la función _callback_ y deben ser del tipo `Error`. Ej: 


      fs.readFile('foo.txt', 'utf8', function(err, data) {
          if(err){
            handleError(err);
          } else {
            processData(data);
          }
      });
---
task: [<< índice de contenidos >>](#contenido)

### Convenciones de Callbacks en NodeJS 

- En CPS asíncrono los errores se tienen que propagar a la siguiente función de callback. Ej:


    const fs = require('fs');

    const readJSON = (filename, callback) => {
      fs.readFile(filename, 'utf8', (err,data)=>{
        
        let parsed;
        
        if(err)
        //propagate the error and exit the current function
        return callback(err);

        try {
          //parse the file contents
          parsed = JSON.parse(data);
        } catch(err) {
        // catch parsing errors
        return callback(err);
        }
        // no errors, propagate just the data

        callback(null, parsed);
      });
    };
---
### Ejercicio5
<hr>
- Crear una función que pase el contenido de un array a un callback y éste genere un nuevo array que multiplique cada valor del array anterior por 2.
 
 TIPS: imitar a la función `Array.map()`


---

name: promesas
class: center, middle, inverse
## [Promesas](#Qué es Node.js?)
---

name:promesas
task: [<< índice de contenidos >>](#contenido)

### Promesas: Intro

Una `promesa` es un objeto que representa la __finalización con éxito o con fallo__ de una __operación asíncrona__. En esencia, una promesa es un objeto retornado al cual se le pueden asignar _callbacks_, en lugar de pasar un _callback_ a una función

Es un recurso para manejar un proceso ásincrono de manera síncrona. Representa un valor que podemos manejar en algún momento, en el futuro de forma más sencilla que los _callbacks_

Una promesa puede ser creada en el código o puede ser devuelta por un package node externo

???
---
task: [<< índice de contenidos >>](#contenido)

### Cómo crear Promesas

Se crean utilizando el operador new sobre el objecto __`Promise`__ pasando como único parametro una función ejecutora. Esta función a su vez recibe dos parametros: un _callback_ que será ejecutado cuando la promesa se ha cumplido (__resolve__) y otro que será ejecutado cuando no (__reject__).

La lógica de programación debe controlar cuándo y dónde llamar a esas funciones. Si la operación tiene éxito se pasan los datos al código que usa la promesa si no, se pasa el error.

```javascript
const miPromesa = new Promise(function(resolve, reject) { 

   if (/* condition */) {
      resolve(/* value */);  // fulfilled successfully
   }
   else {
      reject(/* reason */);  // error, rejected
   }
});
```
---
task: [<< índice de contenidos >>](#contenido)

### Estados de las promesas

De este modo, la `promesa` tiene tres estados:

- **Pendiente**. Hasta que se resuelve, permanece en estado pendiente
- **Completada**. Cuando se invoca la función `resolve` con el valor devuelto.
- **Rechazada**. Si se invoca la función `reject` con un valor de rechazo.

**Una `Promesa` solo puede ser completada o rechazada una vez.**

Una `Promesa` también se puede resolver de forma inmediata utilizando el método **`Promise.resolve()`**

```javascript=
let myMeth = Promise.resolve(42);  
```
---
task: [<< índice de contenidos >>](#contenido)

### Consumir Promesas: `.then()`

Una vez tengamos la promesa, se puede pasar como **valor**. La promesa es una respresentación del valor futuro, y puede ser devuelta a partir de una __función__, pasada como __parámetro__ y usada como cualquier otro valor

**Para consumir la `promesa`** - *es decir, utilizar el valor una vez que se ha completado* - asociamos una __función__ que gestione la promesa usando el método __`.then()`__.

```javascript=
let p = new Promise((resolve, reject) => resolve("BCNcodes"));  
p.then((val) => console.log(val)); // BCNcodes  
```

El método **`.then()`** recibe **dos parámetros posibles**. 

- El primero es la función que se invocará si la promesa se ha completado.
- El segundo es la función que se invocará si la promesa se ha rechazado.
- 
```javascript=
p.then((val) => console.log("fulfilled:", val),  
       (err) => console.log("rejected: ", err));
```
---
task: [<< índice de contenidos >>](#contenido)

### Consumir Promesas: `.catch()`

👀: Si se omite el primer parámetro del método `.then()`, enviando un `null`, sería equivalente a encadenar el método __`Promise.catch()`__, que toma como único parámetro la llamada del rechazo de la promesa.

Son equivalentes:

```javascript=
p.then((val) => console.log("fulfilled:", val))  
 .catch((err) => console.log("rejected:", err));

p.then((val) => console.log("fulfilled:", val))  
 .then(null, (err) => console.log("rejected:", err));
```
Como se ve, la función `.then()` devuelve a su vez una promesa permitiendo que sean encadenadas facilmente. Además el valor que se devuelve en `.then()` se pasa como parámetro al siguiente.

Mejor utilizar **`.catch()`** para gestionar los errores que la expresión __`.then(null, function)`__. __`.catch()`__ es más explícito y se puede encadenar al final de una cadena de promesas, devolviendo cualquier excepción o rechazo de la promesa original o de cualquiera otra. 

???
## Dealing with errors

You should use **`.catch()`** for *handling errors*, rather than `.then(null, function)`. Using **`.catch()`** is more explicit and idiomatic, and when chaining you can have a single `.catch()` at the end of the chain to handle **any rejection or thrown exceptions** from either the original promise or any of it's handlers.

Throwing an exception in a `Promise` will automatically **reject** that `Promise` as well. This is the same for `.then()` handlers and their **results** and **return** values as well. A thrown error is wrapped in a `Promise` and treated as a rejection.
---
task: [<< índice de contenidos >>](#contenido)

### Encadenamiento de promesas

```javascript=
var p1 = new Promise((resolve, reject) => {  
  if (true)  
    throw new Error("rejected!"); 
  else
    resolve(4);
});

p1.then((val) => val + 2)  
 .then((val) => console.log("got", val))
 .catch((err) => console.log("error: ", err.message));
// => error: rejected!
```

![](https://imgur.com/pndfvfg.png)
---
task: [<< índice de contenidos >>](#contenido)

### Ejemplo Promesa 
_(https://scotch.io/tutorials/javascript-promises-for-dummies)_

Imagina que eres pequeñ@ y tu madre te promete que te regalará un móvil nuevo si te portas bien. 

Creamos la promesa:

```javascript
const isMomHappy = true;
const willIGetNewPhone = new Promise((resolve, reject) => { 
    if (isMomHappy) {
        const phone = {
          brand: 'Samsung',
          color: 'black'
        };
        resolve(phone);
    } else {
        const reason = new Error('mom is not happy');
        reject(reason);
    }
});
```
---
task: [<< índice de contenidos >>](#contenido)

### Ejemplo Promesa 
_(https://scotch.io/tutorials/javascript-promises-for-dummies)_

Llamamos a la promesa:

```javascript
const askMom = function() { 
   willIGetNewPhone
      .then(console.log)
      .catch( error =>console.log(error.message));
}

askMom();
```
---
task: [<< índice de contenidos >>](#contenido)

### Ejemplo Promesa 
_(https://scotch.io/tutorials/javascript-promises-for-dummies)_

Ahora prometes que si tienes un móvil nuevo se lo enseñarás a tus amigos. Añades otra promesa

```javascript
const showOff = function (phone) {
  const message = 
      `Hey friend, I have a new ${phone.color} ${phone.brand} phone` ;

  return Promise.resolve(message);
};
// call our promise
const askMom = function () {
  willIGetNewPhone
    .then(showOff)
    .then(fulfilled => console.log(fulfilled)) // fat arrow
    .catch(error => console.log(error.message)); // fat arrow
};

askMom();
```
---
task: [<< índice de contenidos >>](#contenido)

###Ejercicio 6

<hr>

Crear una operación que devuelva el resultado de una suma asíncrona en una promesa. Después elevar al cuadrado el resultado.

- Si algún sumando es 0 devolverá error.
- Si el resultado de la potencia es mayor que 100 devolverá error.

---
###Ejercicio node-meQuiere-noMeQuiere

<hr>

Deshoja la margarita y descubre si tu amad@ te quiere o no te quiere.

### Descripción

- Partís de una margarita de número variable de pétalos.
- Deshojar la margarita significa arrancarle un pétalo cada segundo (tip: pensad en setInterval())
- Cada pétalo __"arrancado"__ significa imprimir en pantalla "me quiere!" o "no me quiere!!!".
- El programa resolverá con el valor último pintado en _AZUL_ si me quiere o en _ROJO_ si no me quiere (tip: chalk)

### Detalles

Devuelve una promesa con el mensaje que toque y encadena la impresión por la consola.
---
task: [<< índice de contenidos >>](#contenido)

### Promesas: Métodos estáticos

- **`Promise.resolve`**: Crea una promesa de cumplimiento
```javascript
let promise = Promise.resolve(valor);
```

- **`Promise.reject`**: Crea una promesa de rechazo
```javascript
let promise = Promise.reject(error);
```

- **`Promise.all`**: Ejecuta muchas promesas en paralelo y espera hasta que todas ellas han terminado. El iterador normalmente es un array que devuelve una promesa. Si se rechazan se devuelve el argumento de la primera promesa que se rechaza. Es un método útil para agregar el resultado de múltiples promesas.

```javascript
Promise.all([
new Promise((resolve, reject) => setTimeout(() => resolve(1), 3000)),// 1
new Promise((resolve, reject) => setTimeout(() => resolve(2), 2000)),// 2
new Promise((resolve, reject) => setTimeout(() => resolve(3), 1000))// 3
]).then(console.log); 
//1,2,3 when promises are ready: each promise contributes an array member
```

???

## Promises All

There will be sometime we will need to wait more than one `Promise` to complete to continue our program, no worries, you can use `Promise.all()`:wink:

The **`Promise.all()`** method returns a single `Promise` that **resolves when all of the promises in the iterable argument have resolved** or when the iterable argument contains no promises. It **rejects with the reason of the first promise that rejects.** This method can be useful for aggregating the results of multiple promises.

**Fulfillment**
- If an empty iterable is passed, then this method returns (synchronously) an already resolved promise.
- If all of the passed-in promises fulfill, or are not promises, the promise returned by `Promise.all` is fulfilled asynchronously.
- In all cases, the **returned promise is fulfilled with an array containing all the values of the iterable passed as argument (also non-promise values).**

**Rejection**
If any of the passed-in promises **reject**, `Promise.all` asynchronously rejects with the value of the **promise that rejected**, whether or not the other promises have resolved.

```javascript=
var p1 = Promise.resolve(3);
var p2 = 1337;
var p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
}); 

Promise.all([p1, p2, p3]).then(values => { 
  console.log(values); // [3, 1337, "foo"] 
});
```
---
task: [<< índice de contenidos >>](#contenido)

### Promesas estáticas: Promise.all

Una estrategia utilizada es mapear un array de datos a un array de promesas y después envolverlo con Promise.all. Ej:

```javascript
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];
// map every url to the promise fetch(github url)

let requests = urls.map(url => fetch(url));

// Promise.all waits until all jobs are resolved

Promise.all(requests)
       .then(responses => responses.forEach(
        response => alert(`${response.url}: ${response.status}`)
));
```

---
task: [<< índice de contenidos >>](#contenido)

### Visualización gráfica de las promesas

```javascript=
Promise.all([
  new Promise(resolve => setTimeout(resolve, 1500)),
  new Promise(resolve => setTimeout(resolve, 900)),
  new Promise(resolve => setTimeout(resolve, 2200))
])
.then(results => results.length.b.c)
.then(c => console.info(c))
.catch(err => console.error(err))
```
<img src="https://imgur.com/f6ii7GH.png" width=50% height=50%>

La web [Promises Visualization](https://bevacqua.github.io/promisees/#) permite comprobar de forma gráfica como se resuelven las promesas después de cada `setTimeout`.
???
Go ahead and play around with the different methods of `Promise`! :muscle: 

## Summary

We just learn a super powerfull tool for dealing with asynchrnous code. `Promises` give us the ability to write asynchronous code in a synchronous fashion, with flat indentation and a single exception channel.

`Promises` give us guarantees of no race conditions and immutability of the future value represented by the `Promise` (unlike callbacks and events). 


---
task: [<< índice de contenidos >>](#contenido)

### Ejercicio 7
<hr>

Recorrer un directorio manejando la respuesta de si es un fichero o un directorio con promesas. 

- Si es un fichero concatenar el nombre del fichero al directorio
- Si es un directorio volver a invocar a la función.
- Obtener el resultado por consola.

---

name: asyncawait
class: center, middle, inverse
## [async|await](#Qué es Node.js?)

---
name: introasync
task: [<< índice de contenidos >>](#contenido)

### async|await

Desde ES7 y nodejs > 6 se introduce la expresión `async`/`await` se utiliza para manejar la asincronía:
- __`async`__ delante de una función significa que esa función devolverá una promesa.

  ```javascript
  async function f(){return 1;}
    f().then(console.log);
  //es igual a async function f() {return Promise.resolve(1)}
  ```
- __`await`__ trabaja sólo con funciones `async` y lo que hace es parar la ejecución del programa hasta que se completa la función `async`.

```javascript
async function f() {
    let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // wait till the promise resolves (*)
  console.log(result); // "done!"
}

f();
```
---
task: [<< índice de contenidos >>](#contenido)

### async|await: Manejo de errores

Manejar los errores con **`try-catch`**

```javascript
async function f() {
  try {
    let response = await fetch('/no-user-here');
    let user = await response.json();
  } catch(err) {
    // catches errors both in fetch and response.json
    alert(err);
  }
}

f();
```
---
### Ejercicio 8
<hr>

Rehacer el ejemplo del "móvil nuevo" con async/await

---
[_Volver al Menú Principal_](/courses/meanstack/content.html)

---
name: eventemitter
class: center, middle, inverse
## [Event-Driven Programming](#Qué es Node.js?)
---

name:eventemitterintro
task: [<< índice de contenidos >>](#contenido)

### EDP: Intro

La __programación orientada a eventos__ es un paradigma de programación en el cual el flujo del programa viene determinado por eventos tales como acciones de usuario (clicks del _mouse_, presión de teclas), salidas de sensores o mensajes de otros programas o hilos de ejecución.

Node usa un model orientado a eventos manejado por una librería llamada __`libuv`__ que proporciona un mecanismo llamado __event loop__.

_El comportamiento es muy parecido al del JavaScript del navegador_

.center[![](https://imgur.com/Yq2Tqwb.png)]
---
name:eventemitterintro
task: [<< índice de contenidos >>](#contenido)

### Event Loop

- Es un único subproceso que realiza todas las operaciones de entrada y salida (I/O) de forma asíncrona

- Es una cola de funciones. Cuando se ejecuta una función asíncrona, la función devuelve el código interno de la función, lo envuelve y se inserta en una cola

- El motor de JavaScript manda las operaciones a la cola y hace que se procesen en segundo plano para no bloquear las demás operaciones

- La librería `libuv`, proporciona la manera de añadir las operaciones necesarias a la cola de forma asíncrona (conocida como threadpool ) y estas operaciones corren de forma nativa en el SO.
---
name:eventemitterintro
task: [<< índice de contenidos >>](#contenido)

### Event Loop: Proceso

El funcionamiento se da de la siguiente
manera:
1. Existe una cola de tareas
2. Se define el número de hilos
3. Cada hilo toma una tarea y la ejecuta
4. Una vez que la tarea esté completa, se disparará otra
5. Si no hay tareas, el subproceso permanece inactivo
6. Si encuentra una nueva tarea en cola se inicia el procesamiento

![](https://imgur.com/jORwIlk.png)
---
### Referencias:

_[Entendiendo la magia detrás de node.js y su event loop](https://blog.nearsoftjobs.com/entendiendo-la-magia-detr%C3%A1s-de-nodejs-y-su-event-loop-8335e3b35e58)_

---
### Patrón Observer

- Define un objecto llamado subject que puede notificar a un grupo de observers (o listeners ) cuando ocurre un cambio de estado
- La diferencia principal con el patron de callback es que el sujeto puede notificar a muchos observadores mientras que un callback es el único listener de la finalización de una tarea asíncrona.
- Las funciones que escuchan los eventos actúan como observadores. Cada vez que un evento se dispara, su función de escucha comienza a ejecutarse.
- Node.js tiene varios eventos incorporados disponibles a través del módulo de `events` y la clase `EventEmitter` que se utilizan para vincular eventos y _events listeners_.
---

### Event Emitter

Crear un objeto `eventEmitter`:

    //Módulo de eventos de importación

    import {EventEmitter} from 'events';

    const eventEmitter = new EventEmitter();

Enlazar un controlador de eventos con un evento:

    //Vincular evento y controlador de eventos

    eventEmitter.on ('eventName', eventHandler);

Lanzar un evento programáticamente de la siguiente manera:

    eventEmitter.emit('eventName');

---

### Event Emitter: Ejemplo

    import {EventEmitter} from 'events';

    const eventEmitter = new EventEmitter();

    //Create an event handler as follows

    const connectHandler = () => {

          console.log('connection succesful.');
      // Fire the data_received event
          eventEmitter.emit('data_received'); 
    }

    // Bind the connection event with the handler
    
    eventEmitter.on ('connection', connectHandler);

    //Bind the data_received event with the anonymous function

    eventEmitter.on('data_received', ()=>{
        console.log('data received succesfully .');
        });

    // Fire the connection event

    eventEmitter.emit ('connection');
    console.log("Program Ended");

---
### Ejercicio 8
<hr>
- Crear un objeto __EventEmitter__ que emita la fecha actual (`Date.now()`) dentro de una función `setInterval()` cada medio segundo.

- Asociar un listener a este evento que imprima la fecha por consola

Realizar el ejercicio anterior con _callbacks_

### Bonus track

Crear una función que acepte un __callback__ y devuelva un `EventEmitter`

---

### Ejercicio 9
<hr>

Crear un objeto __`event emitter`__ que emita un evento al que suscribir dos _listeners_:
  - El primer listener imprimirá del 1 al 100 cada medio segundo
  - El segundo listener imprimirá del 100 al 1 cada segundo
El programa terminará cuando los dos contadores impriman el mismo número.
---
name: buffers
class: center, middle, inverse
## [Buffers](#Qué es Node.js?)
---

name:buffersintro
task: [<< índice de contenidos >>](#contenido)

### Buffers

- Conjuntos de datos en crudo (_raw data_), datos binarios, que podemos tratar en NodeJS para realizar diversos tipos de acciones
- Son instancias para almacenar datos sin procesar similares a una matriz de números enteros

- En Node.js se implementan mediante una clase específica llamada __`Buffer`__

- Se utilizan en la comunicación bidireccional que tenemos cuando manejamos sockets, pero también al manipular imágenes o streams de datos. 

---
name:buffersintro
task: [<< índice de contenidos >>](#contenido)

### Crear un Buffer

- La clase __`Buffer`__ es global en NodeJS, por lo que no necesita ser importada de ningún módulo para poder usarla. 

- El tamaño de un buffer se establece en el momento de su creación y luego ya no es posible cambiarlo.

- Para crear un buffer: 


    let b1 = Buffer.alloc(20);

  _crea un buffer con tamaño de 20 bytes sin contenido. Cada uno de sus bytes estará inicializado a cero_

- Para crear un buffer con contenido:


    var b2 = Buffer.from('Ejemplo de buffer');
    
- En este caso la codificación por defecto es 'utf8'

---

name:buffersintro
task: [<< índice de contenidos >>](#contenido)

### Buffer: Escribir en una cadena

    buffer.write(string[, offset][, length][, encoding])

Descripción de los parámetros utilizados:
- __`String`__: Esta es la cadena de datos que se escribirá en el buffer.
- __`Offset`__: Este es el índice del buffer para comenzar a escribir en un punto establecido, el valor predeterminado es 0.
- __`Length`__: Este es el número de bytes a escribir.
- __`Encoding`__: Codificación a utilizar. 'Utf8' es la codificación predeterminada.

__Valor del retorno__: Este método devuelve el número de octetos escritos. Si no hay suficiente espacio en el buffer para ajustar la cadena entera, escribirá solo una parte de la cadena (hasta donde alcance el espacio).
---

name:buffersintro
task: [<< índice de contenidos >>](#contenido)

### Buffer: Lectura

    buf.toString([encoding][, start][, end])

Descripción de los parametros utilizados:

- __`Encoding`__: Codificación a utilizar. 'Utf8' es la codificación predeterminada.

- __`Start`__: Índice inicial para empezar a leer, el valor predeterminado es 0.

- __`End`__: El índice final de la lectura, por defecto es el buffer completo.

__Valor del retorno__: Este método decodifica y devuelve una cadena de datos lo que esta escrito en el buffer.
---

name:buffersintro
task: [<< índice de contenidos >>](#contenido)

### Buffer: Concatenar buffers

    Buffer.concat(list[, totalLength])

Descripción de los parametros utilizados:

- __`list`__: Lista array de objetos de los buffers a concatenar.

- __`TotalLength`__: Ésta es la longitud total de los buffers cuando están concatenados.

---

### Ejercicio 10
<hr>

Crea un buffer de '__Hola Mundo__' conviértelo a minúsculas y extrae el espacio. Deberá quedar: 

    //holamundo

---
name: streams
class: center, middle, inverse
## [Streams](#Qué es Node.js?)
---

name:streamsintro
task: [<< índice de contenidos >>](#contenido)

### Streams

Objetos que permiten leer datos de una Fuente o escribir datos en un destino en modo continuo:

Cuatro tipos de streams:

__`Readable`__ − Streams de lectura

__`Writable`__ − Streams de escritura

__`Duplex`__ − Stream de lectura/escritura

__`Transform`__ − A type of duplex stream where the output is computed based on input.

Cada tipo de `Stream` es una instancia de `EventEmitter` y emiten distintos _events_ en diferentes instantes de tiempo. Los eventos más comunes son:

__`data`__ − Evento de datos disponibles para lectura

__`end`__ − Evento de no hay más datos de lectura

__`error`__ − Error recibiendo o escribiendo datos

__`finish`__ − Finalización de la tarea

---
name:streamsintro
task: [<< índice de contenidos >>](#contenido)
### Streams: Ejemplo de Lectura

- Crear un `stream` a partir de la lectura de un fichero utilizando el método `createReadStream()` del objeto `fs`:


    import fs from 'fs';
    const streamLectura = fs.createReadStream('./archivo-texto.txt');

- Asociar un evento "__data__" a un _listener_ que se ejecutará cuando el dato se haya leído y se encuentre disponible, recibiendo como parámetro un buffer de datos


    streamLectura.on('data', chunk => //chunk es un buffer de datos
      console.log(chunk instanceof Buffer)); //escribe "true" por pantalla

- Leemos su contenido:


    streamLectura.on('data', chunk =>{ 
        console.log('He recibido ' + chunk.length + ' bytes de datos.');
        console.log(chunk.toString());
    });

---
name:streamsintro
task: [<< índice de contenidos >>](#contenido)
### Ejercicio 11
<hr>
Leer el fichero `movieDetails.json` y mostrar el contenido por consola. Asociar listeners a cada uno de los eventos: data, end, error 
---
name:streamsintro
task: [<< índice de contenidos >>](#contenido)

### `process`

El módulo __`process`__ permite obtener información y modificar el proceso en curso de Node. Al contrario que la mayoría de los módulos, `process` es global y siempre está disponible.

### process events

`process` es una instancia de EventEmitter. 
- El evento __`exit`__ proporciona un espacio de ejecución final antes de salir de Node. El _event loop_ ya no corre después de un evento `exit`


    process.on('exit', function () {
      setTimeout(function () {
      console.log('This will not run');
      }, 100);
      console.log('Bye.');
    });

Otros eventos interesantes: `uncaughtException`

---
name:streamsintro
task: [<< índice de contenidos >>](#contenido)

### process: Operating system input/output

`process`proporciona una serie de `streams` para interaccionar con el sistema operativo: 

__`process.stdin`__
Es un `stream`de lectura. Todo lo que escribimos por el terminal,se lee con `stdin`. Está siempre accesible aunque en modo pausa (Node puede escribir, pero nosotros no podemos leerlo). Para poder utilizarlo es necesario invocar el método `resume()`


    process.stdin.resume();
    process.stdin.setEncoding('utf8');

    process.stdin.on('data', function (chunk) {
      process.stdout.write('data: ' + chunk);
    });

    process.stdin.on('end', function () {
      process.stdout.write('end');
    });
---
name:streamsintro
task: [<< índice de contenidos >>](#contenido)

### process: Operating system I/O

__`process.stdout`__

Es un stream de escritura con el que se puede generar salida del programa. En este caso la consola. 

    process.stdout.write(objetoBuffer);

- Mediante el método `write()` se escribe en un `stream` de escritura. Hay que enviarle un buffer y otra serie de parámetros opcionales como el tipo de codificación y una función _callback_ a ejecutar cuando termine la operación de escritura.


    process.stdin.setEncoding('utf8');
    process.stdout.write('¿Cómo estás hoy? ');
    process.stdin.once('data', function(res) {
    process.stdout.write('Has respondido: ');
    process.stdout.write(res);
    process.stdin.pause();
    })
---
name:streamsintro
task: [<< índice de contenidos >>](#contenido)

### process: Operating system I/O

__`process.argv`__

__`argv`__ es un array que contiene argumentos de la línea de comandos. Comienza con el propio comando node:

    node argv.js -t 3 -c "abc def" -erf       foo.js
    [ 'node',
      '/Users/croucher/argv.js',
      '-t',
      '3',
      '-c',
      'abc def',
      '-erf',
      'foo.js' ]

---
### Ejercicio 12
<hr>

- Reescribir el ejercicio anterior utilizando la propiedad `stdout` en lugar de `console.log`

- Incorporar una petición mediante `stdin` para bajar el fichero. 

- Combinar la salida por consola con los métodos de la propiedad `process.stdin` para entrar información por consola. 

- Usar la interface `readline` para los objetos `stdin/stdout`

---
name:streamsintro
task: [<< índice de contenidos >>](#contenido)

### Streams: Ejemplo de Escritura 

- Ejemplo con el método createWriteStream()


    import fs from "fs";
    const data = 'Simply Easy Learning';
     
    // Create a writable stream
    const writerStream = fs.createWriteStream('output.txt');
     
    // Write the data to stream with encoding to be utf8
    writerStream.write(data,'UTF8');
     
    // Mark the end of file
    writerStream.end();
     
    // Handle stream events --> finish, and error
    writerStream.on('finish', function() {
        console.log("Write completed.");
    });
     
    writerStream.on('error', function(err){
      console.log(err.stack);
    });
     
    console.log("Program Ended");
---
### Ejercicio 13

<hr>

- Leer de la consola un texto y guardarlo en un fichero

---

name:streamsintro
task: [<< índice de contenidos >>](#contenido)

### Pipes
 
Conexión de un stream de lectura con un stream de escritura:


    const streamLectura = fs.createReadStream('./archivo-texto.txt');
    const streamEscritura = fs.createWriteStream('./otro-archivo.txt');

Para conectar los dos streams se usa:


    streamLectura.pipe(streamEscritura);

---

### Ejercicio 14

<hr>

- Copiar de un fichero a otro (ejercicio de pipes)

---
name:streamsintro
task: [<< índice de contenidos >>](#contenido)

### Streams: Encadenando streams

- Mecanismo para conectar la salida de un stream a múltiples streams mediante piping.

- Ejemplo generar archivo comprimido:


    import fs from 'fs';
    import zlib from 'zlib';
     
    // Compress the file input.txt to input.txt.gz
    fs.createReadStream('input.txt')
      .pipe(zlib.createGzip())
      .pipe(fs.createWriteStream('input.txt.gz'));
      
    console.log("File Compressed.");
---

### Ejercicio 14

<hr>

Descomprimir un fichero .gz creado con el ejemplo anterior. Buscar la documentación de la api '__`zlib`__

---

name: fs
task: [<< índice de contenidos >>](#contenido)

### Módulo FileSystem

En NodeJS todas las operaciones de acceso al sistema de archivos están englobadas dentro del módulo "fs" (File System):

      import fs from 'fs';

Los métodos del módulo fs existen en las dos alternativas: síncrona y asíncrona. Ej:

      import fs from 'fs';
 
    // Asynchronous read
    fs.readFile('input.txt', (err, data) => {
      if (err) return console.error(err);
      
      console.log("Asynchronous read: " + data.toString());
    });

    // Synchronous read
    const data = fs.readFileSync('input.txt');
    console.log("Synchronous read: " + data.toString());
     
    console.log("Program Ended");

---

name: filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Abrir un fichero


__`fs.open(path, flags[, mode], callback)`__

      // Asynchronous - Opening File
      console.log("Going to open file!");
      fs.open('input.txt', 'r+', (err, fd) => {
        if (err) {
            return console.error(err);
        }
        console.log("File opened successfully!");     
      });

---

name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Sacar información de un fichero

__`fs.stat(path, callback)`__


      console.log("Going to get file info!");
      fs.stat('input.txt', (err, stats) => {
        if (err) {
            return console.error(err);
        }
        console.log(stats);
        console.log("Got file info successfully!");
        
        // Check file type
        console.log("isFile ? " + stats.isFile());
        console.log("isDirectory ? " + stats.isDirectory());    
      });

---

name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Escribir en un fichero

__`fs.writeFile(filename, data[, options], callback)`__

    console.log("Going to write into existing file");
    fs.writeFile('input.txt', 'Simply Easy Learning!', err => {
      if (err) {
          return console.error(err);
      }
      
      console.log("Data written successfully!");
      console.log("Let's read newly written data");
      fs.readFile('input.txt', (err, data) => {
          if (err) {
            return console.error(err);
          }
          console.log("Asynchronous read: " + data.toString());
      });
    });

---

name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Leer de un fichero

__`fs.read(fd, buffer, offset, length, position, callback)`__

    const buf = new Buffer(1024);
     
    console.log("Going to open an existing file");
    fs.open('input.txt', 'r+', (err, fd) => {
      if (err) {
          return console.error(err);
      }
      console.log("File opened successfully!");
      console.log("Going to read the file");
      fs.read(fd, buf, 0, buf.length, 0, (err, bytes) => {
          if (err){
            console.log(err);
          }
          console.log(bytes + " bytes read");
          
          // Print only read bytes to avoid junk.
          if(bytes > 0){
            console.log(buf.slice(0, bytes).toString());
          }
      });
    });

---
name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Cerrar un fichero

__`fs.close(fd, callback)`__

    const buf = new Buffer(1024);
     
    console.log("Going to open an existing file");
    fs.open('input.txt', 'r+', (err, fd) => {
      if (err) {
          return console.error(err);
      }
      console.log("File opened successfully!");
      console.log("Going to read the file");
      
      fs.read(fd, buf, 0, buf.length, 0, (err, bytes) => {
          if (err){
            console.log(err);
          }
          // Print only read bytes to avoid junk.
          if(bytes > 0){
            console.log(buf.slice(0, bytes).toString());
          }
          // Close the opened file.
          fs.close (fd, err => {
            if (err){
                console.log(err);
            } 
            console.log("File closed successfully.");
          });
      });
    });

---
name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Truncar un fichero

__`fs.ftruncate(fd, len, callback)`__

    const buf = new Buffer(1024);
     
    console.log("Going to open an existing file");
    fs.open('input.txt', 'r+', (err, fd) => {
      if (err) {
          return console.error(err);
      }
      console.log("File opened successfully!");
      console.log("Going to truncate the file after 10 bytes");
      
      // Truncate the opened file.
      fs.ftruncate(fd, 10, err => {
          if (err){
            console.log(err);
          } 
          console.log("File truncated successfully.");
          console.log("Going to read the same file"); 




SIGUE>>>>>>>>>>>>>>>

---
name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Truncar un fichero


<<<<<<<<<<<<<<<<<<<<CONTINUACION


      fs.read(fd, buf, 0, buf.length, 0, (err, bytes) => {
            if (err){
                console.log(err);
            }
     
            // Print only read bytes to avoid junk.
            if(bytes > 0){
                console.log(buf.slice(0, bytes).toString());
            }
     
            // Close the opened file.
            fs.close(fd, err => {
                if (err){
                  console.log(err);
                } 
                console.log("File closed successfully.");
            });
          });
      });
    });

---
name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Borrar un fichero

__`fs.unlink(path, callback)`__


    
      console.log("Going to delete an existing file");

    fs.unlink('input.txt', err => {
      if (err) {
          return console.error(err);
      }
      console.log("File deleted successfully!");
    });
---
name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Crear un directorio

__`fs.mkdir(path[, mode], callback)`__


      console.log("Going to create directory /tmp/test");
      
      fs.mkdir('/tmp/test', err => {
        if (err) {
            return console.error(err);
        }
        console.log("Directory created successfully!");
      });

---
name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Leer un directorio

__`fs.readdir(path, callback)`__

    console.log("Going to read directory /tmp");
    fs.readdir("/tmp/", (err, files) => {
      if (err) {
          return console.error(err);
      }
      files.forEach( file => {
          console.log( file );
      });
    });

---
name:filesystem
task: [<< índice de contenidos >>](#contenido)

### FileSystem: Eliminar un directorio

__`fs.rmdir(path, callback)`__

    
    console.log("Going to delete directory /tmp/test");

    fs.rmdir("/tmp/test", err =>{
      if (err) {
          return console.error(err);
      }
      console.log("Going to read directory /tmp");
      
      fs.readdir("/tmp/", (err, files) => {
          if (err) {
            return console.error(err);
          }
          files.forEach( file => {
            console.log( file );
          });
      });
    });

---

### Ejercicio a entregar
<hr>

Crear un módulo para empaquetar los ejercicios de node sin incluir los directorios node_modules.
